#!/usr/bin/env python3
"""
A generic utility to patch Pydantic v2 models generated by datamodel-code-generator.

1. Fix RootModel[None] unions (any broken anyOf/oneOf → RootModel[None])
2. Turn _all_ fields that collapsed to None⟶Any | None, so validation passes
"""

import sys, re, os

def fix_models(input_path: str, output_path: str) -> None:
    text = open(input_path).read()

    # 1) Union‑fix: same logic as before, but we won't hard‑code the names—
    #    we'll just ensure Union & RootModel are imported so existing fixes work.
    if "RootModel[None]" in text:
        if "from typing import" in text and "Union" not in text:
            text = re.sub(
                r"(from\s+typing\s+import\s+)([^\n]+)",
                r"\1\2, Union",
                text,
                count=1
            )
        elif "from typing import" not in text:
            text = "from typing import Union\n" + text

        if "from pydantic import" in text and "RootModel" not in text:
            text = re.sub(
                r"(from\s+pydantic\s+import\s+)([^\n]+)",
                r"\1\2, RootModel",
                text,
                count=1
            )
        elif "from pydantic import" not in text:
            text = "from pydantic import RootModel\n" + text

        # leave your custom Part/A2ARequest patches here if you still need them…

    # 2) Generic nullable‑field fix:
    #    - Ensure Any is imported
    if "from typing import" in text and "Any" not in text:
        text = re.sub(
            r"(from\s+typing\s+import\s+)([^\n]+)",
            r"\1\2, Any",
            text,
            count=1
        )
    elif "from typing import" not in text:
        text = "from typing import Any\n" + text

    #    - Any field annotated as `None = Field(` → `Any | None = Field(`
    text = re.sub(
        r'(?m)^(\s+)(\w+):\s*None\s*=\s*Field',
        r'\1\2: Any | None = Field',
        text
    )
    #    - And handle Annotated[None, Field(
    text = re.sub(
        r'(?m)^(\s+)(\w+):\s*Annotated\[\s*None\s*,',
        r'\1\2: Annotated[Any | None,',
        text
    )

    open(output_path, "w").write(text)
    print(f"Patched models written to {output_path}")

def main():
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <input.py> <output.py>")
        sys.exit(1)
    inp, outp = sys.argv[1], sys.argv[2]
    if not os.path.exists(inp):
        print(f"Error: {inp} not found")
        sys.exit(1)
    fix_models(inp, outp)

if __name__ == "__main__":
    main()
